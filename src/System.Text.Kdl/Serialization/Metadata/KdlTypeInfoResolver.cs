namespace System.Text.Kdl.Serialization.Metadata
{
    /// <summary>
    /// Contains utilities and combinators acting on <see cref="IKdlTypeInfoResolver"/>.
    /// </summary>
    public static class KdlTypeInfoResolver
    {
        /// <summary>
        /// Combines multiple <see cref="IKdlTypeInfoResolver"/> sources into one.
        /// </summary>
        /// <param name="resolvers">Sequence of contract resolvers to be queried for metadata.</param>
        /// <returns>A <see cref="IKdlTypeInfoResolver"/> combining results from <paramref name="resolvers"/>.</returns>
        /// <exception cref="ArgumentException"><paramref name="resolvers"/> is null.</exception>
        /// <remarks>
        /// The combined resolver will query each of <paramref name="resolvers"/> in the specified order,
        /// returning the first result that is non-null. If all <paramref name="resolvers"/> return null,
        /// then the combined resolver will also return <see langword="null"/>.
        ///
        /// Can be used to combine multiple <see cref="KdlSerializerContext"/> sources,
        /// which typically define contract metadata for small subsets of types.
        /// It can also be used to fall back to <see cref="DefaultKdlTypeInfoResolver"/> wherever necessary.
        /// </remarks>
        public static IKdlTypeInfoResolver Combine(params IKdlTypeInfoResolver?[] resolvers)
        {
            if (resolvers is null)
            {
                ThrowHelper.ThrowArgumentNullException(nameof(resolvers));
            }

            return Combine((ReadOnlySpan<IKdlTypeInfoResolver?>)resolvers);
        }

        /// <summary>
        /// Combines multiple <see cref="IKdlTypeInfoResolver"/> sources into one.
        /// </summary>
        /// <param name="resolvers">Sequence of contract resolvers to be queried for metadata.</param>
        /// <returns>A <see cref="IKdlTypeInfoResolver"/> combining results from <paramref name="resolvers"/>.</returns>
        /// <remarks>
        /// The combined resolver will query each of <paramref name="resolvers"/> in the specified order,
        /// returning the first result that is non-null. If all <paramref name="resolvers"/> return null,
        /// then the combined resolver will also return <see langword="null"/>.
        ///
        /// Can be used to combine multiple <see cref="KdlSerializerContext"/> sources,
        /// which typically define contract metadata for small subsets of types.
        /// It can also be used to fall back to <see cref="DefaultKdlTypeInfoResolver"/> wherever necessary.
        /// </remarks>
        public static IKdlTypeInfoResolver Combine(params ReadOnlySpan<IKdlTypeInfoResolver?> resolvers)
        {
            var resolverChain = new KdlTypeInfoResolverChain();
            foreach (IKdlTypeInfoResolver? resolver in resolvers)
            {
                resolverChain.AddFlattened(resolver);
            }

            return resolverChain.Count == 1 ? resolverChain[0] : resolverChain;
        }

        /// <summary>
        /// Creates a resolver applies modifications to the metadata generated by the source <paramref name="resolver"/>.
        /// </summary>
        /// <param name="resolver">The source resolver generating <see cref="KdlTypeInfo"/> metadata.</param>
        /// <param name="modifier">The delegate modifying non-null <see cref="KdlTypeInfo"/> results.</param>
        /// <returns>A new <see cref="IKdlTypeInfoResolver"/> instance applying the modifications.</returns>
        /// <remarks>
        /// This method is closely related to <see cref="DefaultKdlTypeInfoResolver.Modifiers"/> property
        /// extended to arbitrary <see cref="IKdlTypeInfoResolver"/> instances.
        /// </remarks>
        public static IKdlTypeInfoResolver WithAddedModifier(this IKdlTypeInfoResolver resolver, Action<KdlTypeInfo> modifier)
        {
            if (resolver is null)
            {
                ThrowHelper.ThrowArgumentNullException(nameof(resolver));
            }
            if (modifier is null)
            {
                ThrowHelper.ThrowArgumentNullException(nameof(modifier));
            }

            return resolver is KdlTypeInfoResolverWithAddedModifiers resolverWithModifiers
                ? resolverWithModifiers.WithAddedModifier(modifier)
                : new KdlTypeInfoResolverWithAddedModifiers(resolver, new[] { modifier });
        }

        /// <summary>
        /// Gets a resolver that returns null <see cref="KdlTypeInfo"/> for every type.
        /// </summary>
        internal static IKdlTypeInfoResolver Empty { get; } = new EmptyKdlTypeInfoResolver();

        /// <summary>
        /// Indicates whether the metadata generated by the current resolver
        /// are compatible with the run time specified <see cref="KdlSerializerOptions"/>.
        /// </summary>
        internal static bool IsCompatibleWithOptions(this IKdlTypeInfoResolver? resolver, KdlSerializerOptions options)
            => resolver is IBuiltInKdlTypeInfoResolver bir && bir.IsCompatibleWithOptions(options);
    }

    /// <summary>
    /// A <see cref="IKdlTypeInfoResolver"/> that returns null for all inputs.
    /// </summary>
    internal sealed class EmptyKdlTypeInfoResolver : IKdlTypeInfoResolver, IBuiltInKdlTypeInfoResolver
    {
        public KdlTypeInfo? GetTypeInfo(Type type, KdlSerializerOptions options) => null;
        public bool IsCompatibleWithOptions(KdlSerializerOptions _) => true;
    }

    /// <summary>
    /// Implemented by the built-in converters to avoid rooting
    /// unused resolver dependencies in the context of the trimmer.
    /// </summary>
    internal interface IBuiltInKdlTypeInfoResolver
    {
        /// <summary>
        /// Indicates whether the metadata generated by the current resolver
        /// are compatible with the run time specified <see cref="KdlSerializerOptions"/>.
        /// </summary>
        bool IsCompatibleWithOptions(KdlSerializerOptions options);
    }
}
